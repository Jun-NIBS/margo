classdef RawDataField < dynamicprops
% class definition for raw data maps container

    properties
        raw;
        path;
        fID;
        dim;
        precision;
    end
    
    properties(Hidden = true)
        Parent;
    end
    
    methods
        function obj = RawDataField(varargin)
            
            % set default values
            obj.raw = RawDataMap;
            obj.path = '';
            obj.precision = 'single';
            obj.dim = 0;
            obj.fID = -1;
            obj.Parent = [];
            
            % parse and assign variable inputs
            for i=1:length(varargin)
                if ischar(varargin{i})
                    switch varargin{i}
                        case 'Path'
                            i = i+1;
                            obj.path = varargin{i};
                        case 'Dim'
                            i = i+1;
                            obj.dim = varargin{i};
                        case 'Precision'
                            i = i+1;
                            obj.precision = varargin{i};
                        case 'fID'
                            i = i+1;
                            obj.fID = varargin{i};
                        case 'Parent'
                            i = i+1;
                            obj.Parent = varargin{i};
                    end
                end
            end
            
        end
            
            
        % initialize raw data memmap from raw data file
        function obj = attach(obj)
            try        
                
                if ~isfield(obj.Parent.meta,'num_traces')
                    obj.Parent.meta.num_traces = ...
                        sum(obj.Parent.meta.roi.num_traces);
                end
                if ~isfield(obj.Parent.meta,'num_frames') ||...
                    obj.Parent.meta.num_frames < 2
                    
                    obj.Parent.meta.num_frames = get_n_frames(obj);
                end
                
                % ensure correct dimensions
                ntrace = obj.Parent.meta.num_traces;
                nframe = obj.Parent.meta.num_frames;
                valid_dim = [ntrace nframe 2];
                obj.dim(~ismember(obj.dim,valid_dim))=[];
                if isempty(obj.dim)
                    obj.dim = [nframe 1];
                    
                elseif numel(obj.dim)==1 && obj.dim == nframe
                    obj.dim = [nframe 1];
                    
                elseif (any(obj.dim == ntrace) &&...
                        obj.dim(end) ~= ntrace) || ...
                        ~any(obj.dim == nframe)
                    
                    tmp_dim = [nframe ...
                        obj.dim(obj.dim~=ntrace & obj.dim~= nframe) ...
                        ntrace];
                    obj.dim = tmp_dim;
                end
                
                if exist(obj.path,'file')==2
                    
                    fInfo = dir(obj.path);
                    if ~fInfo(1).bytes
                        return
                    end
                    
                    prcn = obj.precision;
                    if strcmpi(prcn,'logical')
                        attach_binary(obj);
                    else
                        obj.raw.map = memmapfile(obj.path,...
                            'Format',{prcn,fliplr(obj.dim),'raw'});
                    end
                    obj.raw.Parent = obj;

                    % resize if necessary
                    sz = size(obj.raw.map.Data);
                    if any(sz>1)
                        frame_num = sz(sz>1);
                        obj.dim = [frame_num obj.dim];
                        obj.raw.map = memmapfile(obj.path, ...
                            'Format',{obj.precision,fliplr(obj.dim),'raw'});
                    end
                end
                
            catch 
                % try to automatically repair the file path
                try
                    p = obj.Parent.meta.path;
                    updatepaths(obj.Parent,[p.dir p.name],false);
                    obj.raw.map = memmapfile(obj.path, ...
                                'Format',{obj.precision,fliplr(obj.dim),'raw'});
                catch ME
                    switch ME.identifier
                        case 'MATLAB:memmapfile:inaccessibleFile'
                            error(['Failed to initialize raw data map. '...
                                'No such file or directory:\n'...
                                '\t%s'],obj.path);
                    end
                end
            end
            if ~isattached(obj)
                warning(['failed to attach raw data map, '...
                    'automatic raw data file path repair failed']);
            end
            
        end
        
        function obj = detach(obj)
            obj.raw.map = [];
        end
        
        function obj = reset(obj)
            detach(obj);
            attach(obj);
        end
        
        function obj = attach_binary(obj)
            
            obj.fID = fopen(obj.path,'r');           
            if obj.fID ~= -1
                obj.raw.map.Data.raw = ...
                    fread(obj.fID,fliplr(obj.dim),'logical=>logical');
                obj.raw.map.Format = {'logical'};
            else
                error('invalid fileID');
            end
            
        end
        
        function out = isattached(obj)
            try
                out = ~any(~size(obj.raw));
            catch
                out = false;
            end
        end
        
        function out  = size(obj)
            out = obj.dim;
            if numel(out) == 1
                out = [out 1];
            end
        end
        
        % automatically query frame number from raw data
        function out = get_n_frames(obj)

            time = obj.Parent.data.time;
            if exist(time.path,'file')==2
                time_info = dir(time.path);
                f_size = time_info.bytes;
                bytes_per = bytes_per_el(time.precision);
                out = f_size/bytes_per;
            else
                warning(['could not automatically repair frame number'...
                    'from time raw data file, file not found']);
            end
        end
        
        function addprops(obj,props)
            
            if ~iscell(props)
                props = {props};
            end
            
            % remove pre-existing properties from list
            exclude = cellfun(@(p) isprop(obj,p), props);
            props(exclude) = [];
            
            % initialize new properties
            if ~isempty(props)
                cellfun(@(p) addprop(obj,p), props, 'UniformOutput', false);
            end
            
        end
        
        function export_to_csv(obj)
          
            % assigned format_spec
            unsigned_int = {'logical';'uint8';'uint16';'uint32';'uint64'};
            signed_int = {'int8','int16','int32','int64'};
            floating_pt = {'single','double'};
            if any(strcmp(unsigned_int,obj.precision))
                format_spec = '%u,';
            elseif any(strcmp(signed_int,obj.precision))
                format_spec = '%i,';
            elseif any(strcmp(floating_pt,obj.precision))
                format_spec = '%.6f,';
            end
            
            % scale format spec up to length of row and insert newline
            format_spec = [repmat(format_spec,1,obj.dim(end)) '\n'];
            fID = batch_to_csv(obj, format_spec);
            
        end            
    end
end


% exports raw data files to csv in batches
function fID = batch_to_csv(obj, format_spec)

    [csv_dir,csv_name,~] = fileparts(obj.path);
    field = csv_name(find(csv_name=='_',1,'Last')+1:end);
    reset(obj);
    [frames_per_batch, nbatches] = get_batch_sizes(obj.raw);
    
    % write data in batches
    sz = size(obj.raw);
    switch field      
        % proceess x,y separately since centroid is 3 dimensional
        case 'centroid'
            fID(1) = fopen([csv_dir '/' csv_name '_x.csv'],'W+');
            fID(2) = fopen([csv_dir '/' csv_name '_y.csv'],'W');
            for i=1:nbatches
                idx = [(i-1)*frames_per_batch+1 i*frames_per_batch];
                if idx(2) > sz(1)
                    batch_dat_x = obj.raw(idx(1):sz(1),1,:);
                    batch_dat_y = obj.raw(idx(1):sz(1),1,:);
                else
                    batch_dat_x = obj.raw(idx(1):idx(2),1,:);
                    batch_dat_y = obj.raw(idx(1):idx(2),2,:);
                end
                fprintf(fID(1), format_spec, batch_dat_x);
                fprintf(fID(2), format_spec, batch_dat_y);
                reset(obj);
            end
        otherwise
            fID = fopen([csv_dir '/' csv_name '.csv'],'W');
            for i=1:nbatches
                idx = [(i-1)*frames_per_batch+1 i*frames_per_batch];
                if idx(2) > sz(1)
                    batch_dat = obj.raw(idx(1):sz(1),1);
                else
                    batch_dat = obj.raw(idx(1):idx(2),1);
                end
                fprintf(fID, format_spec, batch_dat);
                reset(obj);
            end
    end
    for i=1:numel(fID)
        fclose(fID(i));
    end
end